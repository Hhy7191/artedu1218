<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>나만의 아트보드게임</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&display=swap');
        body { font-family: 'Noto Sans KR', 'Inter', sans-serif; }
        .font-serif { font-family: serif; }
        
        .drawing-canvas {
            background-color: #ffffff;
            touch-action: none;
            cursor: crosshair;
        }
        .template-thumbnail {
            width: 48px; height: 48px;
            object-fit: cover; cursor: pointer;
            transition: all 0.2s; border-radius: 8px;
            border: 2px solid transparent; flex-shrink: 0;
        }
        .template-thumbnail.active { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3); }
        
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        const Icon = ({ name, className = "" }) => {
            const ref = useRef(null);
            useEffect(() => {
                if (lucide.icons[name]) {
                    lucide.createIcons({
                        icons: { [name]: lucide.icons[name] },
                        attrs: { class: className, 'stroke-width': 1.5 }
                    });
                }
            }, [name, className]);
            return <i ref={ref} data-lucide={name} className={className}></i>;
        };

        // --- SECTION 1: Image Association Studio ---
        const ImageAssociationStudio = () => {
            const canvasRef = useRef(null);
            const [mode, setMode] = useState('brush');
            const [color, setColor] = useState('#000000');
            const [size, setSize] = useState(5);
            const [currentTpl, setCurrentTpl] = useState('https://i.postimg.cc/kg20RfFr/1.png');
            const [history, setHistory] = useState([]);
            const [pendingText, setPendingText] = useState('');
            
            const templates = [
                { name: '로르샤흐 1', url: 'https://i.postimg.cc/kg20RfFr/1.png' }, 
                { name: '로르샤흐 2', url: 'https://i.postimg.cc/T3BZVgCY/2.png' }, 
                { name: '로르샤흐 3', url: 'https://i.postimg.cc/Jn3V40Ng/3.png' }, 
                { name: '로르샤흐 4', url: 'https://i.postimg.cc/rmGXFsGm/4.png' }, 
                { name: '로르샤흐 5', url: 'https://i.postimg.cc/nzKbcrKf/5.png' },
                { name: '로르샤흐 6', url: 'https://i.postimg.cc/ZRzzSpdM/6.png' }, 
                { name: '로르샤흐 7', url: 'https://i.postimg.cc/6q9s7KzL/7.png' }, 
                { name: '로르샤흐 8', url: 'https://i.postimg.cc/j2vpP1FY/8.png' }, 
                { name: '로르샤흐 9', url: 'https://i.postimg.cc/cLPVRwT2/9.png' }, 
                { name: '로르샤흐 10', url: 'https://i.postimg.cc/CxR3nmHT/10.png' }
            ];

            useEffect(() => {
                const canvas = canvasRef.current;
                const container = canvas.parentElement;
                canvas.width = container.clientWidth > 800 ? 800 : container.clientWidth - 32;
                canvas.height = canvas.width * 0.75;
                loadTemplate(currentTpl);
            }, []);

            const saveToHistory = () => {
                const canvas = canvasRef.current;
                setHistory(prev => [...prev.slice(-19), canvas.toDataURL()]);
            };

            const loadTemplate = (url) => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = () => {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    const scale = 0.5;
                    const sw = canvas.width * scale;
                    const sh = (img.height / img.width) * sw;
                    ctx.drawImage(img, (canvas.width - sw)/2, (canvas.height - sh)/2, sw, sh);
                    saveToHistory();
                };
                img.src = url;
                setCurrentTpl(url);
            };

            const undo = () => {
                if (history.length <= 1) return;
                const newHistory = [...history];
                newHistory.pop();
                const prevState = newHistory[newHistory.length - 1];
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = prevState;
                setHistory(newHistory);
            };

            const handlePointer = (e) => {
                if (mode !== 'brush') return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                const getPos = (ev) => {
                    const clientX = ev.clientX || (ev.touches && ev.touches[0].clientX);
                    const clientY = ev.clientY || (ev.touches && ev.touches[0].clientY);
                    return {
                        x: (clientX - rect.left) * (canvas.width / rect.width),
                        y: (clientY - rect.top) * (canvas.height / rect.height)
                    };
                };

                if (e.type === 'mousedown' || e.type === 'touchstart') {
                    if (e.cancelable) e.preventDefault();
                    const pos = getPos(e);
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    canvas.isDrawing = true;
                } else if ((e.type === 'mousemove' || e.type === 'touchmove') && canvas.isDrawing) {
                    const pos = getPos(e);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = size;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                } else if (e.type === 'mouseup' || e.type === 'touchend' || e.type === 'mouseleave') {
                    if (canvas.isDrawing) {
                        canvas.isDrawing = false;
                        saveToHistory();
                    }
                }
            };

            const placeText = (e) => {
                if (mode !== 'text' || !pendingText) return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                ctx.fillStyle = color;
                ctx.font = `${size * 2}px Noto Sans KR`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(pendingText, x, y);
                setPendingText('');
                saveToHistory();
            };

            return (
                <div className="flex flex-col gap-8">
                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-gray-100 overflow-hidden">
                        <p className="text-[10px] font-bold tracking-widest text-gray-400 uppercase mb-4">Select Template</p>
                        <div className="flex gap-3 overflow-x-auto pb-2 scrollbar-hide">
                            {templates.map(t => (
                                <img key={t.url} src={t.url} className={`template-thumbnail ${currentTpl === t.url ? 'active' : ''}`} onClick={() => loadTemplate(t.url)} />
                            ))}
                        </div>
                    </div>
                    <div className="flex flex-col lg:flex-row gap-8 items-start">
                        <div className="w-full lg:w-64 bg-white p-6 rounded-3xl shadow-sm border border-gray-100 flex flex-col gap-6">
                            <div className="flex gap-2">
                                <button onClick={() => setMode('brush')} className={`flex-1 p-3 rounded-xl ${mode === 'brush' ? 'bg-blue-600 text-white shadow-lg' : 'bg-gray-50 text-gray-400'}`}><Icon name="paintbrush" /></button>
                                <button onClick={() => setMode('text')} className={`flex-1 p-3 rounded-xl ${mode === 'text' ? 'bg-blue-600 text-white shadow-lg' : 'bg-gray-50 text-gray-400'}`}><Icon name="type" /></button>
                            </div>
                            <div className="space-y-4">
                                <input type="color" value={color} onChange={(e) => setColor(e.target.value)} className="w-full h-10 rounded-xl" />
                                <input type="range" min="1" max="50" value={size} onChange={(e) => setSize(parseInt(e.target.value))} className="w-full accent-blue-600" />
                            </div>
                            {mode === 'text' && <input type="text" placeholder="입력 후 캔버스 클릭" value={pendingText} onChange={(e) => setPendingText(e.target.value)} className="w-full p-3 bg-gray-50 border border-gray-100 rounded-xl text-sm outline-none" />}
                            <div className="pt-4 border-t border-gray-50 flex flex-col gap-2">
                                <button onClick={undo} className="w-full p-3 rounded-xl bg-gray-50 text-gray-600 text-xs font-bold">UNDO</button>
                                <button onClick={() => loadTemplate(currentTpl)} className="w-full p-3 rounded-xl bg-gray-50 text-red-400 text-xs font-bold">CLEAR</button>
                            </div>
                        </div>
                        <div className="flex-1 w-full bg-white p-4 rounded-[40px] shadow-sm border border-gray-100 overflow-hidden">
                            <canvas ref={canvasRef} onMouseDown={mode === 'brush' ? handlePointer : placeText} onMouseMove={handlePointer} onMouseUp={handlePointer} onTouchStart={handlePointer} onTouchMove={handlePointer} onTouchEnd={handlePointer} className={`w-full h-auto rounded-[32px] drawing-canvas`} />
                        </div>
                    </div>
                </div>
            );
        };

        // --- SECTION 2: Art History Learning App ---
        const ArtHistoryLearning = () => {
            const ART_PERIODS = [
                { id: 'renaissance', name: '르네상스 (Renaissance)', period: '14세기 - 16세기', description: '인간 중심의 사고와 과학적 관찰을 바탕으로 원근법과 명암법이 완성된 시기입니다.', keywords: ['인본주의', '투시원근법', '스푸마토', '조화와 균형'], representative: '레오나르도 다 빈치, 미켈란젤로, 라파엘로' },
                { id: 'baroque', name: '바로크 (Baroque)', period: '17세기 - 18세기 초', description: '강렬한 명암 대비와 역동적인 구도, 극적인 감정 표현이 특징인 화려한 양식입니다.', keywords: ['테네브리즘', '역동성', '화려함', '극적 연출'], representative: '카라바조, 렘브란트, 루벤스' },
                { id: 'impressionism', name: '인상주의 (Impressionism)', period: '19세기 후반', description: '빛에 따라 시시각각 변하는 사물의 색채와 순간적인 인상을 포착하려 노력했습니다.', keywords: ['빛의 화가', '필촉 분할법', '야외 제작', '색채의 변화'], representative: '모네, 르누아르, 드가' },
                { id: 'surrealism', name: '초현실주의 (Surrealism)', period: '20세기 초', description: '무의식과 꿈의 세계를 탐구하며 상식을 뛰어넘는 비현실적인 이미지를 결합했습니다.', keywords: ['데페이즈망', '무의식', '프로이트', '자동기술법'], representative: '살바도르 달리, 르네 마그리트' }
            ];

            const [selectedPeriod, setSelectedPeriod] = useState(ART_PERIODS[0]);
            const [userImages, setUserImages] = useState({});
            const [urlInput, setUrlInput] = useState('');
            const [showUrlInput, setShowUrlInput] = useState(false);

            const handleFileUpload = (e, periodId) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => setUserImages(prev => ({ ...prev, [periodId]: reader.result }));
                    reader.readAsDataURL(file);
                }
            };

            const handleUrlSubmit = (periodId) => {
                if (urlInput.trim()) {
                    setUserImages(prev => ({ ...prev, [periodId]: urlInput }));
                    setUrlInput('');
                    setShowUrlInput(false);
                }
            };

            return (
                <div className="grid grid-cols-1 md:grid-cols-12 gap-8">
                    <div className="md:col-span-4 space-y-2">
                        {ART_PERIODS.map((period) => (
                            <button key={period.id} onClick={() => setSelectedPeriod(period)} className={`w-full text-left p-6 rounded-2xl border-2 transition-all ${selectedPeriod.id === period.id ? 'bg-white border-blue-500 shadow-md ring-4 ring-blue-50' : 'bg-white border-transparent text-gray-600'}`}>
                                <div className="font-bold text-[10px] uppercase tracking-wider text-blue-500 mb-1">{period.period}</div>
                                <div className="font-bold text-lg">{period.name}</div>
                            </button>
                        ))}
                    </div>
                    <div className="md:col-span-8 bg-white rounded-[40px] border border-gray-100 shadow-sm overflow-hidden p-8 md:p-12">
                        <h2 className="text-4xl font-light text-slate-900 mb-2">{selectedPeriod.name}</h2>
                        <p className="text-slate-400 font-serif italic mb-10">{selectedPeriod.period}</p>
                        <div className="space-y-10">
                            <section>
                                <h3 className="text-[10px] font-bold text-slate-300 uppercase tracking-widest mb-4">Description</h3>
                                <p className="text-slate-700 leading-relaxed text-lg font-light">{selectedPeriod.description}</p>
                            </section>
                            <div className="relative aspect-video rounded-[32px] bg-gray-50 border-2 border-dashed border-gray-200 flex flex-col items-center justify-center overflow-hidden">
                                {userImages[selectedPeriod.id] ? (
                                    <img src={userImages[selectedPeriod.id]} className="w-full h-full object-cover" />
                                ) : (
                                    <div className="text-center p-6">
                                        <p className="text-gray-400 text-sm mb-4">이미지를 업로드하거나 URL을 입력하세요</p>
                                        <div className="flex gap-2 justify-center">
                                            <label className="px-4 py-2 bg-blue-600 text-white rounded-xl text-xs font-bold cursor-pointer">업로드 <input type="file" className="hidden" onChange={(e) => handleFileUpload(e, selectedPeriod.id)} /></label>
                                            <button onClick={() => setShowUrlInput(!showUrlInput)} className="px-4 py-2 bg-gray-100 text-gray-600 rounded-xl text-xs font-bold">URL</button>
                                        </div>
                                        {showUrlInput && (
                                            <div className="mt-4 flex gap-2"><input type="text" value={urlInput} onChange={(e) => setUrlInput(e.target.value)} className="p-2 border rounded-xl text-sm" placeholder="http://..." />
                                            <button onClick={() => handleUrlSubmit(selectedPeriod.id)} className="bg-gray-900 text-white px-3 rounded-xl text-xs">확인</button></div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- SECTION 3: Elements and Principles ---
        const ElementsAndPrinciples = () => {
            const [selectedElement, setSelectedElement] = useState(null);
            const elements = [
                { id: 'line', title: '선 (Line)', icon: 'spline', desc: '두 점을 잇는 궤적. 속도와 에너지를 가집니다.', tip: '속도감 있는 직선과 부드러운 곡선을 섞어보세요.' },
                { id: 'shape', title: '형 (Shape)', icon: 'shapes', desc: '선이 닫혀 만들어지는 영역. 기하학적 혹은 유기적입니다.', tip: '사각형과 원을 겹쳐 깊이감을 만들어보세요.' },
                { id: 'color', title: '색 (Color)', icon: 'palette', desc: '빛에 의한 감각. 감정을 즉각적으로 전달합니다.', tip: '보색 관계를 활용해 강조점을 찾아보세요.' },
                { id: 'texture', title: '질감 (Texture)', icon: 'grid', desc: '표면의 시각적/촉각적 느낌. 공간에 무게감을 줍니다.', tip: '거친 점들과 부드러운 면을 대조시켜보세요.' }
            ];

            return (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div className="space-y-4">
                        {elements.map(el => (
                            <button key={el.id} onClick={() => setSelectedElement(el)} className={`w-full p-8 rounded-[32px] border-2 text-left transition-all ${selectedElement?.id === el.id ? 'border-blue-500 bg-blue-50/30' : 'border-white bg-white hover:border-gray-100'}`}>
                                <div className="flex items-center gap-4 mb-4">
                                    <div className={`p-4 rounded-2xl ${selectedElement?.id === el.id ? 'bg-blue-600 text-white' : 'bg-gray-50 text-gray-400'}`}><Icon name={el.icon} /></div>
                                    <h3 className="font-bold text-xl">{el.title}</h3>
                                </div>
                                <p className="text-sm text-gray-500 leading-relaxed font-light">{el.desc}</p>
                            </button>
                        ))}
                    </div>
                    <div className="bg-white rounded-[40px] p-10 border border-gray-100 flex flex-col items-center justify-center text-center shadow-sm">
                        {selectedElement ? (
                            <div className="animate-in fade-in slide-in-from-bottom-4 duration-500">
                                <div className="w-24 h-24 rounded-full bg-blue-50 flex items-center justify-center mb-8 mx-auto"><Icon name={selectedElement.icon} className="w-10 h-10 text-blue-600" /></div>
                                <h4 className="text-2xl font-light mb-4">{selectedElement.title} 탐구하기</h4>
                                <div className="p-8 bg-gray-50 rounded-3xl text-sm text-gray-600 italic mb-8 font-serif">" {selectedElement.tip} "</div>
                                <button onClick={() => alert('도전 과제 준비 중')} className="px-12 py-4 bg-gray-900 text-white rounded-2xl text-[10px] font-bold uppercase tracking-widest">Start Challenge</button>
                            </div>
                        ) : (
                            <p className="text-gray-300 font-bold uppercase tracking-widest">Select an element</p>
                        )}
                    </div>
                </div>
            );
        };

        // --- SECTION 4: Creative Studio (IMPROVED IDEA ENGINE) ---
        const CreativeStudio = () => {
            const [ideas, setIdeas] = useState([]);
            const [input, setInput] = useState('');

            const addIdea = () => {
                if (!input.trim()) return;
                // 새로운 아이디어를 추가하면서 드로잉 모드 활성화 상태를 포함
                setIdeas([{ 
                    id: Date.now(), 
                    text: input, 
                    date: new Date().toLocaleTimeString(), 
                    drawing: null,
                    activeDrawing: true // 추가 시 바로 그림 그리기 활성화
                }, ...ideas]);
                setInput('');
            };

            const DrawingArea = ({ ideaId, onSave, isActive }) => {
                const canvasRef = useRef(null);
                const isDrawing = useRef(false);

                useEffect(() => {
                    const canvas = canvasRef.current;
                    const container = canvas.parentElement;
                    canvas.width = container.clientWidth;
                    canvas.height = 250;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }, []);

                const handleDrawing = (e) => {
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    const rect = canvas.getBoundingClientRect();
                    
                    const getCoords = (ev) => {
                        const clientX = ev.clientX || (ev.touches && ev.touches[0].clientX);
                        const clientY = ev.clientY || (ev.touches && ev.touches[0].clientY);
                        return { x: clientX - rect.left, y: clientY - rect.top };
                    };

                    if (e.type === 'mousedown' || e.type === 'touchstart') {
                        if (e.type === 'touchstart' && e.cancelable) e.preventDefault();
                        isDrawing.current = true;
                        const { x, y } = getCoords(e);
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    } else if ((e.type === 'mousemove' || e.type === 'touchmove') && isDrawing.current) {
                        const { x, y } = getCoords(e);
                        ctx.lineTo(x, y);
                        ctx.strokeStyle = '#3b82f6';
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.stroke();
                    } else if (e.type === 'mouseup' || e.type === 'touchend' || e.type === 'mouseleave') {
                        if (isDrawing.current) {
                            isDrawing.current = false;
                            onSave(ideaId, canvas.toDataURL());
                        }
                    }
                };

                const clear = () => {
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    onSave(ideaId, null);
                };

                return (
                    <div className="mt-4 border border-gray-100 rounded-2xl overflow-hidden relative group">
                        <canvas 
                            ref={canvasRef}
                            onMouseDown={handleDrawing}
                            onMouseMove={handleDrawing}
                            onMouseUp={handleDrawing}
                            onMouseLeave={handleDrawing}
                            onTouchStart={handleDrawing}
                            onTouchMove={handleDrawing}
                            onTouchEnd={handleDrawing}
                            className="w-full drawing-canvas"
                        />
                        <button onClick={clear} className="absolute top-2 right-2 p-2 bg-white shadow-sm rounded-lg opacity-0 group-hover:opacity-100 transition-opacity text-red-400">
                            <Icon name="eraser" className="w-4 h-4" />
                        </button>
                    </div>
                );
            };

            const updateIdea = (id, data) => {
                setIdeas(prev => prev.map(i => i.id === id ? { ...i, drawing: data } : i));
            };

            return (
                <div className="max-w-3xl mx-auto space-y-8">
                    <div className="bg-white p-8 rounded-[40px] shadow-sm border border-gray-100">
                        <p className="text-[10px] font-bold text-blue-500 uppercase tracking-widest mb-4">Idea Engine</p>
                        <div className="flex gap-4">
                            <input 
                                type="text" value={input} 
                                onChange={(e) => setInput(e.target.value)} 
                                onKeyPress={(e) => e.key === 'Enter' && addIdea()}
                                placeholder="생각을 적고, 오른쪽 버튼을 눌러 스케치를 시작하세요..."
                                className="flex-1 bg-gray-50 p-6 rounded-2xl outline-none focus:ring-2 ring-blue-100 text-lg font-light"
                            />
                            {/* 검정색 플러스 버튼: 아이디어 추가 및 드로잉 영역 생성 */}
                            <button 
                                onClick={addIdea} 
                                className="bg-gray-900 text-white px-8 rounded-2xl hover:scale-105 active:scale-95 transition-all shadow-lg"
                                title="아이디어 추가 및 드로잉 시작"
                            >
                                <Icon name="plus" className="w-6 h-6" />
                            </button>
                        </div>
                    </div>
                    <div className="space-y-6">
                        {ideas.map(idea => (
                            <div key={idea.id} className="bg-white p-8 rounded-[32px] border border-gray-50 shadow-sm animate-in slide-in-from-top-4">
                                <div className="flex justify-between mb-4">
                                    <h4 className="text-xl font-light text-slate-800">{idea.text}</h4>
                                    <button onClick={() => setIdeas(ideas.filter(i => i.id !== idea.id))} className="text-gray-200 hover:text-red-400 p-2"><Icon name="trash-2" /></button>
                                </div>
                                <p className="text-[10px] font-bold text-blue-400 uppercase tracking-widest mb-2 flex items-center gap-2">
                                    <Icon name="paintbrush" className="w-3 h-3" /> Sketch your idea
                                </p>
                                <DrawingArea ideaId={idea.id} onSave={updateIdea} isActive={idea.activeDrawing} />
                            </div>
                        ))}
                        {ideas.length === 0 && (
                            <div className="py-20 text-center opacity-20">
                                <Icon name="lightbulb" className="w-16 h-16 mx-auto mb-4" />
                                <p className="text-[10px] font-bold uppercase tracking-[0.5em]">Studio is Empty</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const App = () => {
            const [currentPage, setCurrentPage] = useState('main');
            const menuItems = [
                { id: 'image-association', title: '이미지 연상', description: '추상적인 형태에서 나만의 이야기를 발견합니다.', icon: 'palette' },
                { id: 'art-history', title: '미술사 이해', description: '서양 미술사의 주요 흐름을 파악하고 작품을 기록합니다.', icon: 'history' },
                { id: 'elements-principles', title: '조형 요소와 원리', description: '예술을 구성하는 기본적인 문법을 탐구합니다.', icon: 'layout' },
                { id: 'creative-studio', title: '창의력 발전소', description: '글과 스케치로 예술적 아이디어를 구체화합니다.', icon: 'lightbulb' }
            ];

            if (currentPage === 'main') {
                return (
                    <div className="min-h-screen bg-white px-6 py-24 flex flex-col items-center">
                        <header className="w-full max-w-5xl mb-24">
                            <h1 className="text-[10px] font-bold tracking-[0.5em] text-slate-300 uppercase mb-6">Art Board Lab</h1>
                            <h2 className="text-5xl md:text-7xl font-light tracking-tighter leading-[1.1]">감각을 깨우는 <br /><span className="font-serif italic text-slate-700">창의적 예술 실험</span></h2>
                        </header>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-px bg-slate-100 max-w-5xl w-full border-y">
                            {menuItems.map(item => (
                                <button key={item.id} onClick={() => setCurrentPage(item.id)} className="bg-white p-12 md:p-16 flex flex-col items-start text-left hover:bg-slate-50 transition-all duration-500">
                                    <Icon name={item.icon} className="mb-12 w-10 h-10 text-slate-900" />
                                    <h3 className="text-2xl font-medium mb-4">{item.title}</h3>
                                    <p className="text-slate-400 font-light text-sm mb-12 leading-relaxed">{item.description}</p>
                                    <div className="mt-auto text-[10px] font-bold tracking-widest uppercase text-slate-300 flex items-center">Enter Studio <Icon name="arrow-right" className="ml-2 w-3 h-3" /></div>
                                </button>
                            ))}
                        </div>
                    </div>
                );
            }

            const activeItem = menuItems.find(i => i.id === currentPage);
            return (
                <div className="min-h-screen bg-gray-50/30">
                    <nav className="p-8 sticky top-0 bg-white/80 backdrop-blur-xl z-20 border-b">
                        <div className="max-w-5xl mx-auto flex justify-between items-center">
                            <button onClick={() => setCurrentPage('main')} className="text-[10px] font-bold uppercase tracking-widest text-slate-400 hover:text-slate-900 flex items-center">
                                <Icon name="arrow-left" className="mr-2 w-3 h-3" /> Back to Lab
                            </button>
                            <span className="text-[10px] font-bold uppercase tracking-widest text-blue-500">{activeItem.title} Studio</span>
                        </div>
                    </nav>
                    <main className="max-w-5xl mx-auto px-6 py-20">
                        <div className="mb-20">
                            <h2 className="text-5xl font-light mb-4">{activeItem.title}</h2>
                            <p className="text-slate-400 italic font-serif text-lg">{activeItem.description}</p>
                        </div>
                        {currentPage === 'image-association' && <ImageAssociationStudio />}
                        {currentPage === 'art-history' && <ArtHistoryLearning />}
                        {currentPage === 'elements-principles' && <ElementsAndPrinciples />}
                        {currentPage === 'creative-studio' && <CreativeStudio />}
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>